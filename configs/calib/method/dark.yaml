# ======================================================================
# Dark Current Subtraction — SpectraMind V50
# ======================================================================
# Removes sensor dark current and fixed-pattern offsets from frames.
# Apply after ADC/CDS, before FLAT/TRACE/PHASE/PHOTOMETRY.
#
# CLI:
#   spectramind calibrate +calib.method=dark
#
# Implementation:
#   spectramind.pipeline.calibrate.methods.DarkCalibration
#
# Notes:
# - Supports FITS/NPY/NPZ/CSV for master darks (auto-detected).
# - Safe on CPU/GPU; chunked processing avoids OOM on Kaggle.
# - Optional temperature/exposure scaling & hot-pixel inpaint.
# ======================================================================

# ----------------------------------------------------------------------
# Wiring
# ----------------------------------------------------------------------
_target_: spectramind.pipeline.calibrate.methods.DarkCalibration
_convert_: all

enable: true
apply_to: ["fgs1", "airs"]     # sensors/streams this step applies to

# ----------------------------------------------------------------------
# Source of dark signal
#   file   : use provided master dark map
#   model  : parametric model → exptime/temperature scaling
#   median : compute per-pixel median from a dark stack (debug/bootstraps)
# ----------------------------------------------------------------------
source: file                    # [file | model | median]

file:
  master_dark: ${paths.data}/calib/master_dark.fits
  # If master shape ≠ input shape, pick alignment policy (prefer exact)
  align:
    mode: "exact"               # [exact | tile | resize]
    resize_interpolation: "nearest"  # when mode=resize
  unit: "adu"                   # [adu | flux]; if "adu", gain applied during ADC, not here

model:
  # Simple linear model: dark[e-/s] ≈ base + (temp_coeff * (T - T0))
  # Final subtraction uses: dark_map = (rate * exptime) converted to current units
  base_rate_e_per_s: 0.01       # baseline dark rate
  temp_coeff_per_C: 0.0005      # additional e-/s per +1°C
  T0_C: 0.0                     # reference temperature for base_rate
  # If per-pixel structure desired, provide a template to scale (optional)
  template_file: null           # e.g., ${paths.data}/calib/master_dark_template.npy
  template_scale: 1.0
  # Unit conversion if working in ADU: dark_adu = dark_e * (1/gain_e_per_adu)
  gain_e_per_adu: null          # set if unit conversion required

median:
  # Build a master dark from a stack found at path (lazy-loaded if memmap OK)
  stack_path: ${paths.data}/calib/dark_stack/          # directory or npz
  robust_reject:
    enable: true
    method: "mad"             # [mad | zscore]
    z: 6.0
    iters: 2

# ----------------------------------------------------------------------
# Scaling options
# ----------------------------------------------------------------------
scale_by_exptime: true          # use exptime key or FITS header
exptime_key: "EXPTIME"          # metadata key when available (sec)

scale_by_temperature: false     # enable if reliable telemetry exists
temperature_key: "DET_TEMP"     # metadata key (°C)
temperature_unit: "C"           # [C | K]

# ----------------------------------------------------------------------
# Hot pixel handling
# ----------------------------------------------------------------------
hot_pixels:
  detect: true
  detection_mode: "zscore"      # [zscore | mad | percentile | none]
  threshold: 8.0                # z or MAD-sigma threshold
  min_cluster: 1                # ignore isolated detections below this count
  persist_mask_file: null       # write cumulative BPM (1=bad) if set
  replace: true
  inpaint_method: "median3"     # [median3 | bilateral | zero | none]
  grow_radius: 0                # dilate BPM by N px (0=disabled)

# Use upstream/static mask(s) in addition to detections
masking:
  external_masks: []            # e.g., ["fgs1_bpm","airs_bpm"] or file paths
  drop_frame_if_bad_fraction: 0.5  # drop frame if >50% pixels masked (0..1)

# ----------------------------------------------------------------------
# Post-processing guards
# ----------------------------------------------------------------------
clamp_min_zero: true            # avoid negative flux after subtraction
clip:
  enable: false                 # optional winsorization of residuals
  sigma: 6.0
  iters: 1

# ----------------------------------------------------------------------
# Backend, dtype, and numerical safety
# ----------------------------------------------------------------------
backend: auto                   # [auto | numpy | torch]
device: auto                    # [auto | cpu | cuda] (torch only)
dtype_out: float32
numeric:
  eps: 1.0e-9
  deterministic: true
  num_threads: ${oc.env:SM_NUM_THREADS, 2}

# ----------------------------------------------------------------------
# Chunking (OOM safety on Kaggle/CI)
# ----------------------------------------------------------------------
chunking:
  enabled: true
  frames_per_chunk: 64          # split T into blocks; null → auto
  min_frames_per_chunk: 8

# ----------------------------------------------------------------------
# I/O & caching
# ----------------------------------------------------------------------
io:
  allow_memmap: true            # memmap large NPY/NPZ/FITS when possible
  eager_load: false             # load master fully at start
  cache_dir: ${paths.runtime}/cache/dark

# ----------------------------------------------------------------------
# Validation gates (fail fast if pathological)
# ----------------------------------------------------------------------
validate: true
validation:
  finite_input: true            # input must be finite
  finite_output: true
  # Expect mean/variance reduction after subtraction (tolerances below)
  expect_reduced_mean: true
  expect_reduced_var: true
  max_mean_increase: 0.02       # allow ≤2% mean increase (edge cases)
  max_var_increase: 0.05        # allow ≤5% variance increase
  max_hot_fraction: 0.01        # ≤1% pixels flagged hot per frame
  # If master alignment performed, enforce identical shapes at exit
  enforce_shape_match: true

# ----------------------------------------------------------------------
# Output keys
# ----------------------------------------------------------------------
outputs:
  corrected_key: "dark_corrected"     # per-sensor pipeline may override
  bpm_key: "bpm"                      # cumulative bad-pixel mask (1=bad)
  meta_prefix: "dark"

# ----------------------------------------------------------------------
# Diagnostics (optional)
# ----------------------------------------------------------------------
diagnostics:
  enable: false
  histogram_before_after: false
  save_maps: 0                     # N frames of (raw, master, corrected)
  save_hotmap: false               # write hot pixel map(s)
  out_dir: ${paths.runtime}/reports/dark

# ----------------------------------------------------------------------
# Repro metadata (recorded in run logs)
# ----------------------------------------------------------------------
meta:
  name: "Dark Subtraction"
  version: "v1"
  checksum_inputs: true            # record sha256 of master/template files
  log_level: INFO                  # [CRITICAL | ERROR | WARNING | INFO | DEBUG]