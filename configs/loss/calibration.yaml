# configs/loss/calibration.yaml
# ----------------------------------------------------------------------
# Calibration Loss — SpectraMind V50
# ----------------------------------------------------------------------
# Penalizes miscalibrated uncertainties from the heteroscedastic decoder.
# Supplements Gaussian LL by encouraging well-calibrated variance/coverage.
#
# Components (set λ=0.0 to disable):
#   - variance calibration   (σ² vs empirical residuals)
#   - coverage calibration   (Gaussian CI coverage vs target 1−α)
#   - ECE-style calibration  (empirical vs nominal quantile coverage)
#
# Usage:
#   # standalone (for ablations)
#   python -m spectramind.train +loss=calibration
#
#   # via composite loss (recommended; see ADR 0002)
#   python -m spectramind.train loss=composite \
#     loss.params.calibration.var_lambda=1e-4 \
#     loss.params.calibration.alpha=0.1
# ----------------------------------------------------------------------

_target_: spectramind.losses.calibration.CalibrationLoss

# ----- Component weights (>= 0; 0 disables the term) ------------------
var_lambda: 1.0e-4          # variance fidelity: σ² ≈ (μ − y)² (or log-space, see var_mode)
cover_lambda: 0.0           # coverage of Gaussian CI (target = 1 − α)
ece_lambda: 0.0             # ECE-style quantile calibration

# ----- Variance calibration controls ----------------------------------
# var_mode:
#   * "mse"      : MSE between σ² and residual²   (σ² vs (μ − y)²)
#   * "log_mse"  : MSE between log(σ²) and log(residual² + eps)  [more scale-stable]
#   * "l1"       : L1 version of "mse"
var_mode: "log_mse"

# residual_type:
#   * "raw"          : r = (y − μ)
#   * "standardized" : r = (y − μ) / clamp(σ, sigma_min, sigma_max)
residual_type: "raw"

# Normalization for variance calibration:
#   "none" | "per_bin" | "per_batch" | "global"
var_normalization: "per_batch"

# ----- Coverage calibration controls ----------------------------------
alpha: 0.10                 # nominal CI: 1 − α (e.g. 0.90 CI if alpha=0.1)
ci_tail: "two_sided"        # ["two_sided","upper","lower"]

# ----- ECE-style quantile calibration ---------------------------------
# Compare empirical coverage to nominal across quantiles
ece_bins: 20                # total bins; too high -> noisy
ece_min_bins: 5
ece_max_bins: 50
ece_min_per_bin: 32         # avoid volatile bins on small batches
ece_smoothing: 1.0          # Laplace smoothing count (0 disables)
ece_bootstrap: 0            # # of bootstraps for robust ECE estimate (0 disables)

# ----- FGS1 handling (bin 0 dominates challenge metric ~58×) ----------
use_fgs1_weight: true       # upweight contributions at bin 0
fgs1_weight: 58.0           # applied consistently to var/cover/ece terms at bin 0

# ----- Numerical stability & clamping ---------------------------------
eps: 1.0e-8                 # jitter for logs/divisions
sigma_min: 1.0e-6           # keep σ in a reasonable band (match GLL)
sigma_max: 1.0e+2

# ----- Aggregation / masking ------------------------------------------
reduction: "mean"           # ["mean","sum","none"]
mask_invalid: true          # ignore NaN/Inf residuals or σ

# ----- Optional annealing (helps avoid early over-constraint) ----------
schedule:
  enabled: false
  kind: "cosine"            # ["linear","cosine"]
  # global schedule multiplies each active lambda by the factor below
  start_factor: 0.0
  end_factor: 1.0
  warmup_epochs: 2
  total_epochs: 50

# ----- Diagnostics / logging -------------------------------------------
log_scalars: true           # log per-component scalar losses
log_histograms: false       # log residuals, σ, standardized residuals, ECE bin stats
log_interval: 1             # epochs between logs (if logger enabled)
