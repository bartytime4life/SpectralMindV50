# configs/data/splits.yaml
# ======================================================================
# Dataset split configuration — SpectraMind V50
# ----------------------------------------------------------------------
# Consumed by the DataModule BEFORE DataLoaders are built.
# Select with e.g.:
#   +data.splits.scheme=holdout
#   +data.splits.scheme=kfold +data.splits.kfold.n_splits=5
#   +data.splits.scheme=precomputed +data.splits.precomputed.path=...
# ======================================================================

splits:

  # One of: ["holdout", "kfold", "timeseries", "precomputed"]
  scheme: kfold

  # Reproducibility
  seed: ${oc.env:SM_SPLIT_SEED,1337}

  # Column mapping (names must exist in the in-memory metadata DataFrame)
  columns:
    id:         ${oc.env:SM_COL_ID,id}                  # unique sample id
    group:      ${oc.env:SM_COL_GROUP,star_id}          # group id (prevents leakage across splits)
    stratify:   ${oc.env:SM_COL_STRAT,target_bucket}    # label/bucket for class balance
    time:       ${oc.env:SM_COL_TIME,obs_mjd}           # numeric/time for ordering (timeseries)

  # -------------------------------
  # KFold settings
  # -------------------------------
  kfold:
    n_splits: ${oc.env:SM_KFOLDS,5}
    shuffle:  true
    # Resolution priority:
    #   1) columns.group      → GroupKFold (no group leakage)
    #   2) columns.stratify   → StratifiedKFold (balanced bins)
    #   3) else               → KFold
    # If both group & stratify provided → group takes precedence.

  # -------------------------------
  # Holdout settings
  # -------------------------------
  holdout:
    val_size:   ${oc.env:SM_VAL_SIZE,0.1}    # fraction in (0,1] OR absolute count
    test_size:  ${oc.env:SM_TEST_SIZE,0.0}   # 0 disables a separate test split
    shuffle:    true
    # Same resolution priority as kfold.

  # -------------------------------
  # Time series split (walk-forward)
  # -------------------------------
  timeseries:
    n_splits:       ${oc.env:SM_TS_SPLITS,5}
    max_train_size: null           # int or null (unbounded)
    # Requires columns.time to be present & sortable ascending.

  # -------------------------------
  # Precomputed splits
  # -------------------------------
  # Expected file has at least {id, split} or {id, fold}
  #   - KFold-like → integer "fold" ∈ [0..n_splits-1]
  #   - Holdout-like → string  "split" ∈ {"train","val","test"}
  precomputed:
    path:    null                  # set to CSV/Parquet path when used
    format:  ${oc.env:SM_SPLITS_FMT,csv}     # csv|parquet
    id_col:  ${splits.columns.id}
    fold_col:  fold
    split_col: split

  # -------------------------------
  # Constraints / guardrails
  # -------------------------------
  constraints:
    disjoint_groups_across_splits: true   # group leak guard
    disjoint_time_future_leak:     true   # max(train.time) < min(val/test.time) for timeseries
    enforce_min_per_fold:          1      # each fold must contain ≥ N samples
    enforce_strata_balance:        true   # if stratify set, check per-fold class support

  # -------------------------------
  # Export artifacts (for DVC / reproducibility)
  # -------------------------------
  export:
    enable: ${oc.env:SM_EXPORT_SPLITS,true}
    dir:    ${oc.env:SM_EXPORT_SPLITS_DIR,./configs/data/splits_artifacts}
    format: ${oc.env:SM_EXPORT_SPLITS_FMT,csv} # csv|parquet
    # Filenames include scheme/seed/timestamp, e.g.: splits_kfold_s5_seed1337_YYYYMMDD_HHMM.csv
    include_columns:
      - ${splits.columns.id}
      - ${splits.columns.group}
      - ${splits.columns.stratify}
      - ${splits.columns.time}

  # -------------------------------
  # Diagnostics (printed once on build/load)
  # -------------------------------
  diagnostics:
    show_class_balance: true      # requires stratify
    show_group_overlap: true
    show_time_windows:  true
    print_head:          5        # 0 disables

  # -------------------------------
  # Runtime checks (raise if violated)
  # -------------------------------
  strict:
    require_columns:          true     # referenced columns must exist
    require_precomputed_path: true     # when scheme == precomputed
    error_on_empty_fold:      true     # guard degenerate folds
