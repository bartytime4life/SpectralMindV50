name: artifact-sweeper

on:
  schedule:
    - cron: "30 3 * * 0"   # Sundays 03:30 UTC
  workflow_dispatch:
    inputs:
      days_to_keep:
        description: 'Delete artifacts older than this many days'
        required: false
        default: '14'
      grace_days:
        description: 'Extra buffer beyond days_to_keep before deletion'
        required: false
        default: '2'
      keep_latest_per_name:
        description: 'Always keep the N most-recent per artifact name'
        required: false
        default: '5'
      min_size_kb:
        description: 'Only delete artifacts >= this size (KB); 0 disables'
        required: false
        default: '0'
      dry_run:
        description: 'Show what would be deleted without deleting (true/false)'
        required: false
        default: 'true'
      protect_patterns:
        description: 'Comma-separated globs to preserve (e.g. "release-*,sbom*")'
        required: false
        default: 'release-*,sbom*'
      include_patterns:
        description: 'Comma-separated globs to consider (default: all artifacts)'
        required: false
        default: '*'

permissions:
  actions: write     # list/delete artifacts + run logs
  contents: read

concurrency:
  group: artifact-sweeper-${{ github.ref }}
  cancel-in-progress: true

jobs:
  sweep:
    name: ðŸ§¹ Sweep artifacts & old run logs
    runs-on: ubuntu-latest
    timeout-minutes: 25

    steps:
      - name: Resolve inputs
        id: cfg
        shell: bash
        run: |
          # Inputs are empty for cron; set safe defaults
          DAYS="${{ github.event.inputs.days_to_keep || '14' }}"
          GRACE="${{ github.event.inputs.grace_days || '2' }}"
          KEEP_N="${{ github.event.inputs.keep_latest_per_name || '5' }}"
          MIN_KB="${{ github.event.inputs.min_size_kb || '0' }}"
          DRY="${{ github.event.inputs.dry_run || 'true' }}"
          PROTECT="${{ github.event.inputs.protect_patterns || 'release-*,sbom*' }}"
          INCLUDE="${{ github.event.inputs.include_patterns || '*' }}"
          echo "days=${DAYS}"   >> "$GITHUB_OUTPUT"
          echo "grace=${GRACE}" >> "$GITHUB_OUTPUT"
          echo "keep=${KEEP_N}" >> "$GITHUB_OUTPUT"
          echo "min=${MIN_KB}"  >> "$GITHUB_OUTPUT"
          echo "dry=${DRY}"     >> "$GITHUB_OUTPUT"
          echo "protect=${PROTECT}" >> "$GITHUB_OUTPUT"
          echo "include=${INCLUDE}" >> "$GITHUB_OUTPUT"

      - name: ðŸ§¾ Plan & prune artifacts (age/filters/keep-N; retries/backoff)
        id: prune
        uses: actions/github-script@v8
        with:
          days: ${{ steps.cfg.outputs.days }}
          grace: ${{ steps.cfg.outputs.grace }}
          keep: ${{ steps.cfg.outputs.keep }}
          min_kb: ${{ steps.cfg.outputs.min }}
          dry: ${{ steps.cfg.outputs.dry }}
          protect: ${{ steps.cfg.outputs.protect }}
          include: ${{ steps.cfg.outputs.include }}
          script: |
            // ---------- inputs ----------
            const daysToKeep = parseInt(core.getInput('days') || '14', 10);
            const graceDays  = Math.max(0, parseInt(core.getInput('grace') || '0', 10));
            const keepLatest = Math.max(0, parseInt(core.getInput('keep') || '5', 10));
            const minSizeKB  = Math.max(0, parseInt(core.getInput('min_kb') || '0', 10));
            const dryRun = (core.getInput('dry') || 'true').toLowerCase() === 'true';
            const toList = (s) => (s ?? '').split(',').map(x => x.trim()).filter(Boolean);
            const protectGlobs = toList(core.getInput('protect'));
            const includeGlobs = toList(core.getInput('include') || '*');

            // ---------- helpers ----------
            const globToRegex = (g) => new RegExp('^' + g
              .replace(/[.+^${}()|[\]\\]/g,'\\$&').replace(/\*/g,'.*').replace(/\?/g,'.') + '$','i');
            const protectRx = protectGlobs.map(globToRegex);
            const includeRx = includeGlobs.map(globToRegex);
            const matchesAny = (n, rx) => rx.length === 0 || rx.some(r => r.test(n));
            const cutoff = Date.now() - (daysToKeep + graceDays)*24*60*60*1000;
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            async function delWithRetry(id, attempt=1) {
              try {
                await github.rest.actions.deleteArtifact({ owner: context.repo.owner, repo: context.repo.repo, artifact_id: id });
                return true;
              } catch (e) {
                const s = e.status || 0;
                if (attempt < 5 && [403,429,502,503,504].includes(s)) {
                  const backoff = Math.min(2000*attempt, 8000);
                  core.info(`retry ${attempt} delete ${id} after ${backoff}ms (${s})`);
                  await sleep(backoff); return delWithRetry(id, attempt+1);
                }
                core.error(`delete ${id} failed: ${s} ${(e.message||e)}`); return false;
              }
            }
            const fmtBytes = (n)=>{const u=['B','KB','MB','GB','TB'];let i=0,x=n;while(x>=1024&&i<u.length-1){x/=1024;i++;}return `${x.toFixed(2)} ${u[i]}`;}

            // ---------- fetch all artifacts ----------
            const artifacts = await github.paginate(
              github.rest.actions.listArtifactsForRepo,
              { owner: context.repo.owner, repo: context.repo.repo, per_page: 100 }
            );

            // group by name to keep newest N
            const byName = new Map();
            for (const a of artifacts) {
              const n = a.name || `artifact-${a.id}`;
              if (!byName.has(n)) byName.set(n, []);
              byName.get(n).push(a);
            }
            for (const a of byName.values()) {
              a.sort((x,y) => new Date(y.created_at) - new Date(x.created_at));
            }

            let total=0, considered=0, deleted=0, kept=0, protectedCount=0, expired=0, errors=0, tooSmall=0;
            let bytesScanned=0, bytesDeleted=0;

            for (const art of artifacts) {
              total++;
              const name = art.name || `artifact-${art.id}`;
              const size = Number(art.size_in_bytes || 0);
              const created = new Date(art.created_at || art.updated_at || Date.now()).getTime();
              bytesScanned += size;

              // include filter
              if (!matchesAny(name, includeRx)) { kept++; continue; }

              // protect filter
              if (protectRx.length && protectRx.some(r => r.test(name))) { protectedCount++; continue; }

              // keep newest N per name
              const siblings = byName.get(art.name || '') ?? [];
              const idx = siblings.findIndex(x => x.id === art.id);
              if (idx > -1 && idx < keepLatest) { kept++; continue; }

              // expired or missing -> purge regardless of age
              if (art.expired || !art.archive_download_url) {
                expired++;
                if (!dryRun) { const ok = await delWithRetry(art.id); ok ? (deleted++, bytesDeleted+=size) : errors++; }
                continue;
              }

              // age cutoff
              if (created > cutoff) { kept++; continue; }

              // size guard
              if (minSizeKB > 0 && size < minSizeKB*1024) { tooSmall++; kept++; continue; }

              considered++;
              if (dryRun) {
                core.info(`[DRY] would delete: ${name} (#${art.id}) ~ ${fmtBytes(size)}`);
              } else {
                const ok = await delWithRetry(art.id);
                if (ok) { deleted++; bytesDeleted += size; } else { errors++; }
              }
            }

            core.summary
              .addHeading('Artifact Sweeper Report')
              .addTable([
                [{data:'Metric',header:true},{data:'Value',header:true}],
                ['Days to keep', String(daysToKeep)],
                ['Grace days', String(graceDays)],
                ['Keep latest per name', String(keepLatest)],
                ['Min size (KB)', String(minSizeKB)],
                ['Dry run', String(dryRun)],
                ['Protected patterns', protectGlobs.join(', ') || '(none)'],
                ['Included patterns', includeGlobs.join(', ') || '(all)'],
                ['Total scanned', String(total)],
                ['Considered', String(considered)],
                ['Deleted', String(deleted)],
                ['Expired auto-deleted', String(expired)],
                ['Too small kept', String(tooSmall)],
                ['Kept (recent/other)', String(kept)],
                ['Errors', String(errors)],
                ['Bytes scanned', fmtBytes(bytesScanned)],
                ['Bytes deleted (est.)', fmtBytes(bytesDeleted)],
              ]).write();

            core.setOutput('deleted', String(deleted));
            core.setOutput('errors', String(errors));

      - name: ðŸ§¹ Sweep workflow run logs (older than 30 days)
        uses: actions/github-script@v8
        with:
          script: |
            const cutoff = Date.now() - 30*24*60*60*1000;
            const runs = await github.paginate(
              github.rest.actions.listWorkflowRunsForRepo,
              { owner: context.repo.owner, repo: context.repo.repo, per_page: 100, status: "completed" }
            );
            let pruned = 0, errors = 0;
            for (const run of runs) {
              if (new Date(run.updated_at).getTime() < cutoff) {
                try {
                  await github.rest.actions.deleteWorkflowRunLogs({
                    owner: context.repo.owner, repo: context.repo.repo, run_id: run.id
                  });
                  pruned++;
                } catch (e) {
                  errors++;
                  core.warning(`Failed to delete logs for run ${run.id}: ${e.message || e}`);
                }
              }
            }
            core.summary.addHeading('Run Log Sweeper').addList([
              `Completed runs checked: ${runs.length}`,
              `Logs pruned: ${pruned}`,
              `Errors: ${errors}`,
              `Cutoff: 30 days`
            ]).write();

      - name: Upload sweep summary
        if: always()
        run: cp "$GITHUB_STEP_SUMMARY" artifact-sweeper-summary.md

      - name: Upload summary artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: artifact-sweeper-summary
          path: artifact-sweeper-summary.md
          retention-days: 7