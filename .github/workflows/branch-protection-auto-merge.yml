name: branch-protection-auto-merge

on:
  pull_request:
    types: [labeled, reopened, synchronize, ready_for_review]
  workflow_dispatch:
    inputs:
      required_label:
        description: 'Label that enables auto-merge'
        required: false
        default: 'automerge'
      merge_method:
        description: 'squash | merge | rebase'
        required: false
        default: 'squash'
      min_approvals:
        description: 'Minimum number of PR approvals'
        required: false
        default: '1'
      require_up_to_date:
        description: 'Require PR branch to be up-to-date with base (true/false)'
        required: false
        default: 'true'

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

concurrency:
  group: automerge-pr-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: false

jobs:
  preflight:
    name: Preflight eligibility checks
    runs-on: ubuntu-latest

    outputs:
      eligible: ${{ steps.gates.outputs.eligible }}
      reason: ${{ steps.gates.outputs.reason }}
      merge_method: ${{ steps.params.outputs.merge_method }}
      required_label: ${{ steps.params.outputs.required_label }}

    steps:
      - name: Resolve params
        id: params
        shell: bash
        run: |
          # Pull-request context values (empty for workflow_dispatch)
          PR_NUM="${{ github.event.pull_request.number || '' }}"

          REQUIRED_LABEL="${{ github.event.inputs.required_label || 'automerge' }}"
          MERGE_METHOD="${{ github.event.inputs.merge_method || 'squash' }}"
          MIN_APPROVALS="${{ github.event.inputs.min_approvals || '1' }}"
          REQUIRE_UP_TO_DATE="${{ github.event.inputs.require_up_to_date || 'true' }}"

          echo "pr=${PR_NUM}" >> "$GITHUB_OUTPUT"
          echo "required_label=${REQUIRED_LABEL}" >> "$GITHUB_OUTPUT"
          echo "merge_method=${MERGE_METHOD}" >> "$GITHUB_OUTPUT"
          echo "min_approvals=${MIN_APPROVALS}" >> "$GITHUB_OUTPUT"
          echo "require_up_to_date=${REQUIRE_UP_TO_DATE}" >> "$GITHUB_OUTPUT"

      - name: Gate checks
        id: gates
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const requiredLabel = core.getInput('required_label') || 'automerge';
            const minApprovals = parseInt(core.getInput('min_approvals') || '1', 10);
            const requireUpToDate = (core.getInput('require_up_to_date') || 'true').toLowerCase() === 'true';

            // Get PR (works for both PR trigger and manual dispatch if recent)
            const prNumber = context.payload.pull_request?.number;
            if (!prNumber) {
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Not running on a pull_request event.');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber
            });

            const reasons = [];
            const labels = (pr.labels || []).map(l => (typeof l === 'string' ? l : l.name));
            const hasLabel = labels.includes(requiredLabel);

            // Draft check
            if (pr.draft) reasons.push('PR is still a draft.');

            // Label gate
            if (!hasLabel) reasons.push(`Missing required label: '${requiredLabel}'.`);

            // Mergeability basic (conflicts)
            if (pr.mergeable_state === 'dirty') reasons.push('PR has merge conflicts.');
            if (pr.locked) reasons.push('PR is locked.');

            // Up-to-date with base (optional)
            if (requireUpToDate && pr.mergeable_state === 'behind') {
              reasons.push('Branch is behind base; update required.');
            }

            // Approvals: count unique approving reviewers
            const reviews = await github.paginate(
              github.rest.pulls.listReviews,
              { owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber, per_page: 100 }
            );
            const approvers = new Map();
            for (const r of reviews) {
              if (r.state?.toUpperCase() === 'APPROVED' && r.user?.login) {
                approvers.set(r.user.login, true);
              }
              if (r.state?.toUpperCase() === 'CHANGES_REQUESTED' && r.user?.login) {
                // A changes-requested should negate that reviewerâ€™s approval until they re-approve
                approvers.delete(r.user.login);
              }
            }
            const approvalCount = approvers.size;
            if (approvalCount < minApprovals) {
              reasons.push(`Not enough approvals (${approvalCount}/${minApprovals}).`);
            }

            // Status checks & check runs
            const ref = pr.head.sha;
            const checks = await github.rest.checks.listForRef({
              owner: context.repo.owner, repo: context.repo.repo, ref, per_page: 100
            });
            const statuses = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner, repo: context.repo.repo, ref
            });

            const checkRunsOk = (checks.data.check_runs || []).every(cr => {
              // Allow neutral/skipped for optional checks
              return ['success', 'neutral', 'skipped'].includes((cr.conclusion || '').toLowerCase());
            });
            const statusesOk = (statuses.data.statuses || []).every(s => {
              return ['success', 'neutral'].includes((s.state || '').toLowerCase());
            });

            if (!checkRunsOk || !statusesOk) {
              reasons.push('Required checks are not all successful.');
            }

            // Draft final decision
            const eligible = reasons.length === 0 ? 'true' : 'false';
            core.setOutput('eligible', eligible);
            core.setOutput('reason', reasons.join(' '));

            // Nice summary
            core.summary
              .addHeading('Auto-merge Preflight')
              .addTable([
                [{data: 'Property', header: true},{data: 'Value', header: true}],
                ['Label present', String(hasLabel)],
                ['Draft', String(!!pr.draft)],
                ['Mergeable state', pr.mergeable_state || 'unknown'],
                ['Approvals', String(approvalCount)],
                ['Checks OK', String(checkRunsOk && statusesOk)],
                ['Require up-to-date', String(requireUpToDate)],
                ['Eligible', eligible],
              ])
              .addRaw(reasons.length ? `\n**Reasons:** ${reasons.join(' ')}\n` : '\nAll gates passed.\n')
              .write();

  enable:
    name: Enable auto-merge
    runs-on: ubuntu-latest
    needs: preflight
    if: needs.preflight.outputs.eligible == 'true'
    steps:
      - name: Enable auto-merge (peter-evans)
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          merge-method: ${{ needs.preflight.outputs.merge_method }}

  on-ineligible-comment:
    name: Comment on PR when ineligible
    runs-on: ubuntu-latest
    needs: preflight
    if: needs.preflight.outputs.eligible != 'true' && github.event_name == 'pull_request'
    steps:
      - name: Explain why auto-merge not enabled
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            const reason = `${{ toJson(needs.preflight.outputs.reason) }}`.replace(/^"|"$/g,'');
            const body = [
              `ðŸ›‘ **Auto-merge not enabled**`,
              ``,
              `**Reason(s):** ${reason || 'unknown'}`,
              ``,
              `> Add the required label and satisfy gates (approvals, checks, up-to-date).`,
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body
            });