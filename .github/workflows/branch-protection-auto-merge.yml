name: branch-protection-auto-merge

on:
  pull_request:
    types: [labeled, reopened, synchronize, ready_for_review]
  workflow_dispatch:
    inputs:
      required_label:
        description: 'Label that enables auto-merge'
        required: false
        default: 'automerge'
      merge_method:
        description: 'squash | merge | rebase'
        required: false
        default: 'squash'
      min_approvals:
        description: 'Minimum number of PR approvals'
        required: false
        default: '1'
      require_up_to_date:
        description: 'Require PR branch to be up-to-date with base (true/false)'
        required: false
        default: 'true'

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

concurrency:
  group: automerge-pr-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: false

jobs:
  preflight:
    name: Preflight eligibility checks
    runs-on: ubuntu-latest
    outputs:
      eligible: ${{ steps.gates.outputs.eligible }}
      reason: ${{ steps.gates.outputs.reason }}
      merge_method: ${{ steps.params.outputs.merge_method }}
      required_label: ${{ steps.params.outputs.required_label }}
      require_up_to_date: ${{ steps.params.outputs.require_up_to_date }}
    steps:
      - name: Resolve params
        id: params
        shell: bash
        run: |
          PR_NUM="${{ github.event.pull_request.number || '' }}"

          REQUIRED_LABEL="${{ github.event.inputs.required_label || 'automerge' }}"
          MERGE_METHOD="${{ github.event.inputs.merge_method || 'squash' }}"
          MIN_APPROVALS="${{ github.event.inputs.min_approvals || '1' }}"
          REQUIRE_UP_TO_DATE="${{ github.event.inputs.require_up_to_date || 'true' }}"

          echo "pr=${PR_NUM}" >> "$GITHUB_OUTPUT"
          echo "required_label=${REQUIRED_LABEL}" >> "$GITHUB_OUTPUT"
          echo "merge_method=${MERGE_METHOD}" >> "$GITHUB_OUTPUT"
          echo "min_approvals=${MIN_APPROVALS}" >> "$GITHUB_OUTPUT"
          echo "require_up_to_date=${REQUIRE_UP_TO_DATE}" >> "$GITHUB_OUTPUT"

      - name: Gate checks
        id: gates
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const requiredLabel = `${{ steps.params.outputs.required_label }}` || 'automerge';
            const minApprovals = parseInt(`${{ steps.params.outputs.min_approvals }}` || '1', 10);
            const requireUpToDate = (`${{ steps.params.outputs.require_up_to_date }}` || 'true').toLowerCase() === 'true';

            const prNumber = context.payload.pull_request?.number;
            if (!prNumber) {
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Not running on a pull_request event.');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber
            });

            const reasons = [];
            const labels = (pr.labels || []).map(l => (typeof l === 'string' ? l : l.name));
            const hasLabel = labels.includes(requiredLabel);

            if (pr.draft) reasons.push('PR is still a draft.');
            if (!hasLabel) reasons.push(`Missing required label: '${requiredLabel}'.`);
            if (pr.mergeable_state === 'dirty') reasons.push('PR has merge conflicts.');
            if (pr.locked) reasons.push('PR is locked.');

            if (requireUpToDate && pr.mergeable_state === 'behind') {
              reasons.push('Branch is behind base; update required.');
            }

            // Approvals
            const reviews = await github.paginate(
              github.rest.pulls.listReviews,
              { owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber, per_page: 100 }
            );
            const approvers = new Map();
            for (const r of reviews) {
              if (r.state?.toUpperCase() === 'APPROVED' && r.user?.login) {
                approvers.set(r.user.login, true);
              }
              if (r.state?.toUpperCase() === 'CHANGES_REQUESTED' && r.user?.login) {
                approvers.delete(r.user.login);
              }
            }
            const approvalCount = approvers.size;
            if (approvalCount < minApprovals) {
              reasons.push(`Not enough approvals (${approvalCount}/${minApprovals}).`);
            }

            // Checks & statuses
            const ref = pr.head.sha;
            const checks = await github.rest.checks.listForRef({
              owner: context.repo.owner, repo: context.repo.repo, ref, per_page: 100
            });
            const statuses = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner, repo: context.repo.repo, ref
            });

            const checkRunsOk = (checks.data.check_runs || []).every(cr =>
              ['success', 'neutral', 'skipped'].includes((cr.conclusion || '').toLowerCase())
            );
            const statusesOk = (statuses.data.statuses || []).every(s =>
              ['success', 'neutral'].includes((s.state || '').toLowerCase())
            );

            if (!checkRunsOk || !statusesOk) {
              reasons.push('Required checks are not all successful.');
            }

            const eligible = reasons.length === 0 ? 'true' : 'false';
            core.setOutput('eligible', eligible);
            core.setOutput('reason', reasons.join(' '));

            core.summary
              .addHeading('Auto-merge Preflight')
              .addTable([
                [{data: 'Property', header: true},{data: 'Value', header: true}],
                ['Label present', String(hasLabel)],
                ['Draft', String(!!pr.draft)],
                ['Mergeable state', pr.mergeable_state || 'unknown'],
                ['Approvals', String(approvalCount)],
                ['Checks OK', String(checkRunsOk && statusesOk)],
                ['Require up-to-date', String(requireUpToDate)],
                ['Eligible', eligible],
              ])
              .addRaw(reasons.length ? `\n**Reasons:** ${reasons.join(' ')}\n` : '\nAll gates passed.\n')
              .write();

  update-branch:
    name: Update branch if behind
    runs-on: ubuntu-latest
    needs: preflight
    if: |
      needs.preflight.outputs.eligible != 'true' &&
      contains(needs.preflight.outputs.reason, 'update required')
    steps:
      - name: Update PR branch from base
        uses: peter-evans/update-branch@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          # default 'merge' keeps history; change to 'rebase' if your policy prefers
          merge_method: merge
          required_approving_review_count: 0

  preflight-verify:
    name: Re-check eligibility after update
    runs-on: ubuntu-latest
    needs: [preflight, update-branch]
    if: needs.update-branch.result == 'success'
    outputs:
      eligible: ${{ steps.gates.outputs.eligible }}
      reason: ${{ steps.gates.outputs.reason }}
    steps:
      - name: Re-run gates
        id: gates
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request?.number;
            if (!prNumber) { core.setOutput('eligible','false'); core.setOutput('reason','No PR context'); return; }
            const { data: pr } = await github.rest.pulls.get({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber });
            const reasons = [];
            if (pr.draft) reasons.push('PR is still a draft.');
            if (pr.mergeable_state === 'dirty') reasons.push('PR has merge conflicts.');

            const ref = pr.head.sha;
            const checks = await github.rest.checks.listForRef({ owner: context.repo.owner, repo: context.repo.repo, ref, per_page: 100 });
            const statuses = await github.rest.repos.getCombinedStatusForRef({ owner: context.repo.owner, repo: context.repo.repo, ref });

            const checkRunsOk = (checks.data.check_runs || []).every(cr =>
              ['success', 'neutral', 'skipped'].includes((cr.conclusion || '').toLowerCase())
            );
            const statusesOk = (statuses.data.statuses || []).every(s =>
              ['success', 'neutral'].includes((s.state || '').toLowerCase())
            );

            if (!checkRunsOk || !statusesOk) reasons.push('Required checks are not all successful (post-update).');

            const eligible = reasons.length === 0 ? 'true' : 'false';
            core.setOutput('eligible', eligible);
            core.setOutput('reason', reasons.join(' '));
            core.summary.addHeading('Auto-merge Preflight (Post-Update)').addRaw(eligible === 'true' ? '\nAll gates passed.\n' : `\n**Reasons:** ${reasons.join(' ')}\n`).write();

  enable:
    name: Enable auto-merge
    runs-on: ubuntu-latest
    needs: [preflight, preflight-verify]
    if: |
      (needs.preflight.outputs.eligible == 'true') ||
      (needs.preflight-verify.outputs.eligible == 'true')
    steps:
      - name: Enable auto-merge (GitHub native)
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          merge-method: ${{ needs.preflight.outputs.merge_method }}

  on-ineligible-comment:
    name: Comment on PR when ineligible
    runs-on: ubuntu-latest
    needs: [preflight, preflight-verify]
    if: |
      github.event_name == 'pull_request' &&
      (needs.preflight.outputs.eligible != 'true') &&
      (needs.preflight-verify.result != 'success' || needs.preflight-verify.outputs.eligible != 'true')
    steps:
      - name: Explain why auto-merge not enabled
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            const reason1 = `${{ toJson(needs.preflight.outputs.reason) }}`.replace(/^"|"$/g,'');
            const reason2 = `${{ toJson(needs.preflight-verify.outputs.reason || '') }}`.replace(/^"|"$/g,'');
            const reasons = [reason1, reason2].filter(Boolean).join(' | ');
            const body = [
              `🛑 **Auto-merge not enabled**`,
              ``,
              `**Reason(s):** ${reasons || 'unknown'}`,
              ``,
              `> Ensure required label, approvals, passing checks, and an up-to-date branch.`,
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body
            });
