name: branch-protection-auto-merge

on:
  pull_request:
    types: [labeled, reopened, synchronize, ready_for_review]
  workflow_dispatch:
    inputs:
      required_labels:
        description: 'Comma-separated label(s) that enable auto-merge'
        required: false
        default: 'automerge'
      label_mode:
        description: 'Require ALL or ANY of the required_labels (all|any)'
        required: false
        default: 'any'
      veto_labels:
        description: 'Comma-separated labels that block auto-merge if present'
        required: false
        default: 'do-not-merge'
      merge_method:
        description: 'squash | merge | rebase'
        required: false
        default: 'squash'
      min_approvals:
        description: 'Minimum number of PR approvals'
        required: false
        default: '1'
      allow_author_approval:
        description: 'Count PR author approval toward min_approvals (true/false)'
        required: false
        default: 'false'
      require_up_to_date:
        description: 'Require PR branch up-to-date with base (true/false)'
        required: false
        default: 'true'
      max_changed_files:
        description: 'Optional: Max total changed files allowed'
        required: false
        default: ''
      max_additions:
        description: 'Optional: Max total additions allowed'
        required: false
        default: ''
      max_deletions:
        description: 'Optional: Max total deletions allowed'
        required: false
        default: ''

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

concurrency:
  group: automerge-pr-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: false

jobs:
  preflight:
    name: Preflight eligibility checks
    runs-on: ubuntu-latest
    outputs:
      eligible: ${{ steps.gates.outputs.eligible }}
      reason: ${{ steps.gates.outputs.reason }}
      merge_method: ${{ steps.params.outputs.merge_method }}
      require_up_to_date: ${{ steps.params.outputs.require_up_to_date }}
    steps:
      - name: Resolve params
        id: params
        shell: bash
        run: |
          PR_NUM="${{ github.event.pull_request.number || '' }}"

          REQUIRED_LABELS="${{ github.event.inputs.required_labels || 'automerge' }}"
          LABEL_MODE="${{ github.event.inputs.label_mode || 'any' }}"
          VETO_LABELS="${{ github.event.inputs.veto_labels || 'do-not-merge' }}"
          MERGE_METHOD="${{ github.event.inputs.merge_method || 'squash' }}"
          MIN_APPROVALS="${{ github.event.inputs.min_approvals || '1' }}"
          ALLOW_AUTHOR_APPROVAL="${{ github.event.inputs.allow_author_approval || 'false' }}"
          REQUIRE_UP_TO_DATE="${{ github.event.inputs.require_up_to_date || 'true' }}"
          MAX_CHANGED_FILES="${{ github.event.inputs.max_changed_files || '' }}"
          MAX_ADDITIONS="${{ github.event.inputs.max_additions || '' }}"
          MAX_DELETIONS="${{ github.event.inputs.max_deletions || '' }}"

          echo "pr=${PR_NUM}" >> "$GITHUB_OUTPUT"
          echo "required_labels=${REQUIRED_LABELS}" >> "$GITHUB_OUTPUT"
          echo "label_mode=${LABEL_MODE}" >> "$GITHUB_OUTPUT"
          echo "veto_labels=${VETO_LABELS}" >> "$GITHUB_OUTPUT"
          echo "merge_method=${MERGE_METHOD}" >> "$GITHUB_OUTPUT"
          echo "min_approvals=${MIN_APPROVALS}" >> "$GITHUB_OUTPUT"
          echo "allow_author_approval=${ALLOW_AUTHOR_APPROVAL}" >> "$GITHUB_OUTPUT"
          echo "require_up_to_date=${REQUIRE_UP_TO_DATE}" >> "$GITHUB_OUTPUT"
          echo "max_changed_files=${MAX_CHANGED_FILES}" >> "$GITHUB_OUTPUT"
          echo "max_additions=${MAX_ADDITIONS}" >> "$GITHUB_OUTPUT"
          echo "max_deletions=${MAX_DELETIONS}" >> "$GITHUB_OUTPUT"

      - name: Gate checks
        id: gates
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const toList = (s) => (s ?? '')
              .split(',')
              .map(x => x.trim())
              .filter(Boolean);

            const requiredLabels = toList(`${{ steps.params.outputs.required_labels }}`);
            const labelMode = (`${{ steps.params.outputs.label_mode }}` || 'any').toLowerCase();
            const vetoLabels = toList(`${{ steps.params.outputs.veto_labels }}`);

            const minApprovals = parseInt(`${{ steps.params.outputs.min_approvals }}` || '1', 10);
            const allowAuthorApproval = (`${{ steps.params.outputs.allow_author_approval }}` || 'false').toLowerCase() === 'true';
            const requireUpToDate = (`${{ steps.params.outputs.require_up_to_date }}` || 'true').toLowerCase() === 'true';

            const maxChangedFiles = parseInt(`${{ steps.params.outputs.max_changed_files }}` || '0', 10);
            const maxAdditions = parseInt(`${{ steps.params.outputs.max_additions }}` || '0', 10);
            const maxDeletions = parseInt(`${{ steps.params.outputs.max_deletions }}` || '0', 10);

            const prNumber = context.payload.pull_request?.number;
            if (!prNumber) {
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Not running on a pull_request event.');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber
            });

            const reasons = [];
            const prAuthor = pr.user?.login || '';
            const labels = (pr.labels || []).map(l => (typeof l === 'string' ? l : l.name || '')).filter(Boolean);

            // Label gates
            const hasRequired =
              requiredLabels.length === 0
                ? true
                : (labelMode === 'all'
                      ? requiredLabels.every(l => labels.includes(l))
                      : requiredLabels.some(l => labels.includes(l)));
            if (!hasRequired) reasons.push(`Missing required label(s) (${labelMode.toUpperCase()}): ${requiredLabels.join(', ')}`);

            const hasVeto = vetoLabels.length > 0 && vetoLabels.some(l => labels.includes(l));
            if (hasVeto) reasons.push(`Veto label present: ${vetoLabels.join(', ')}`);

            // Draft / locked / conflicts
            if (pr.draft) reasons.push('PR is still a draft.');
            if (pr.locked) reasons.push('PR is locked.');
            if (pr.mergeable_state === 'dirty') reasons.push('PR has merge conflicts.');

            // Up-to-date gate
            if (requireUpToDate && pr.mergeable_state === 'behind') {
              reasons.push('Branch is behind base; update required.');
            }

            // Size gates (optional)
            if (Number.isFinite(maxChangedFiles) && maxChangedFiles > 0 && pr.changed_files > maxChangedFiles) {
              reasons.push(`Too many changed files (${pr.changed_files}/${maxChangedFiles}).`);
            }
            if (Number.isFinite(maxAdditions) && maxAdditions > 0 && pr.additions > maxAdditions) {
              reasons.push(`Too many additions (${pr.additions}/${maxAdditions}).`);
            }
            if (Number.isFinite(maxDeletions) && maxDeletions > 0 && pr.deletions > maxDeletions) {
              reasons.push(`Too many deletions (${pr.deletions}/${maxDeletions}).`);
            }

            // Approvals (exclude bots; optionally exclude PR author)
            const isBot = (u) => (u?.type || '').toLowerCase() === 'bot' || (u?.login || '').toLowerCase().endsWith('[bot]');
            const reviews = await github.paginate(
              github.rest.pulls.listReviews,
              { owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber, per_page: 100 }
            );
            const approvers = new Map();
            for (const r of reviews) {
              const login = r.user?.login;
              if (!login || isBot(r.user)) continue;
              if (!allowAuthorApproval && login === prAuthor) continue;

              const state = (r.state || '').toUpperCase();
              if (state === 'APPROVED') approvers.set(login, true);
              if (state === 'CHANGES_REQUESTED') approvers.delete(login);
            }
            const approvalCount = approvers.size;
            if (approvalCount < minApprovals) {
              reasons.push(`Not enough approvals (${approvalCount}/${minApprovals}).`);
            }

            // Checks & statuses (required checks must be successful or neutral/skipped)
            const ref = pr.head.sha;
            const checks = await github.rest.checks.listForRef({
              owner: context.repo.owner, repo: context.repo.repo, ref, per_page: 100
            });
            const statuses = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner, repo: context.repo.repo, ref
            });

            const checkRunsOk = (checks.data.check_runs || []).every(cr =>
              ['success', 'neutral', 'skipped'].includes((cr.conclusion || '').toLowerCase())
            );
            const statusesOk = (statuses.data.statuses || []).every(s =>
              ['success', 'neutral'].includes((s.state || '').toLowerCase())
            );

            if (!checkRunsOk || !statusesOk) {
              reasons.push('Required checks are not all successful.');
            }

            const eligible = reasons.length === 0 ? 'true' : 'false';
            core.setOutput('eligible', eligible);
            core.setOutput('reason', reasons.join(' '));

            core.summary
              .addHeading('Auto-merge Preflight')
              .addTable([
                [{data: 'Property', header: true},{data: 'Value', header: true}],
                ['Required labels mode', labelMode.toUpperCase()],
                ['Required labels present', String(hasRequired)],
                ['Veto labels present', String(hasVeto)],
                ['Draft', String(!!pr.draft)],
                ['Mergeable state', pr.mergeable_state || 'unknown'],
                ['Approvals', String(approvalCount)],
                ['Checks OK', String(checkRunsOk && statusesOk)],
                ['Require up-to-date', String(requireUpToDate)],
                ['Size gates (files/add/del)', `${pr.changed_files}/${pr.additions}/${pr.deletions}`],
                ['Eligible', eligible],
              ])
              .addRaw(reasons.length ? `\n**Reasons:** ${reasons.join(' ')}\n` : '\nAll gates passed.\n')
              .write();

  update-branch:
    name: Update branch if behind
    runs-on: ubuntu-latest
    needs: preflight
    if: |
      needs.preflight.outputs.eligible != 'true' &&
      contains(needs.preflight.outputs.reason, 'update required')
    steps:
      - name: Update PR branch from base
        uses: peter-evans/update-branch@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          merge_method: merge
          required_approving_review_count: 0

  preflight-verify:
    name: Re-check eligibility after update
    runs-on: ubuntu-latest
    needs: [preflight, update-branch]
    if: needs.update-branch.result == 'success'
    outputs:
      eligible: ${{ steps.gates.outputs.eligible }}
      reason: ${{ steps.gates.outputs.reason }}
    steps:
      - name: Re-run gates
        id: gates
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request?.number;
            if (!prNumber) { core.setOutput('eligible','false'); core.setOutput('reason','No PR context'); return; }
            const { data: pr } = await github.rest.pulls.get({ owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber });

            const reasons = [];
            if (pr.draft) reasons.push('PR is still a draft.');
            if (pr.mergeable_state === 'dirty') reasons.push('PR has merge conflicts.');

            const ref = pr.head.sha;
            const checks = await github.rest.checks.listForRef({ owner: context.repo.owner, repo: context.repo.repo, ref, per_page: 100 });
            const statuses = await github.rest.repos.getCombinedStatusForRef({ owner: context.repo.owner, repo: context.repo.repo, ref });
            const checkRunsOk = (checks.data.check_runs || []).every(cr =>
              ['success', 'neutral', 'skipped'].includes((cr.conclusion || '').toLowerCase())
            );
            const statusesOk = (statuses.data.statuses || []).every(s =>
              ['success', 'neutral'].includes((s.state || '').toLowerCase())
            );
            if (!checkRunsOk || !statusesOk) reasons.push('Required checks are not all successful (post-update).');

            const eligible = reasons.length === 0 ? 'true' : 'false';
            core.setOutput('eligible', eligible);
            core.setOutput('reason', reasons.join(' '));
            core.summary.addHeading('Auto-merge Preflight (Post-Update)').addRaw(eligible === 'true' ? '\nAll gates passed.\n' : `\n**Reasons:** ${reasons.join(' ')}\n`).write();

  enable:
    name: Enable auto-merge
    runs-on: ubuntu-latest
    needs: [preflight, preflight-verify]
    if: |
      (needs.preflight.outputs.eligible == 'true') ||
      (needs.preflight-verify.outputs.eligible == 'true')
    steps:
      - name: Enable auto-merge (GitHub native)
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          merge-method: ${{ needs.preflight.outputs.merge_method }}

  on-ineligible-comment:
    name: Comment on PR when ineligible
    runs-on: ubuntu-latest
    needs: [preflight, preflight-verify]
    if: |
      github.event_name == 'pull_request' &&
      (needs.preflight.outputs.eligible != 'true') &&
      (needs.preflight-verify.result != 'success' || needs.preflight-verify.outputs.eligible != 'true')
    steps:
      - name: Explain why auto-merge not enabled
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            const reason1 = `${{ toJson(needs.preflight.outputs.reason) }}`.replace(/^"|"$/g,'');
            const reason2 = `${{ toJson(needs.preflight-verify.outputs.reason || '') }}`.replace(/^"|"$/g,'');
            const reasons = [reason1, reason2].filter(Boolean).join(' | ');
            const body = [
              `ðŸ›‘ **Auto-merge not enabled**`,
              ``,
              `**Reason(s):** ${reasons || 'unknown'}`,
              ``,
              `> Ensure enabling label(s), no veto labels, sufficient approvals, successful required checks, size thresholds, and an up-to-date branch.`,
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body
            });