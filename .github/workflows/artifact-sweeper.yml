name: artifact-sweeper

on:
  schedule:
    - cron: '30 5 * * 1'   # Every Monday 05:30 UTC
  workflow_dispatch:
    inputs:
      days_to_keep:
        description: 'Delete artifacts older than this many days'
        required: false
        default: '14'
      grace_days:
        description: 'Extra buffer beyond days_to_keep before deletion'
        required: false
        default: '2'
      dry_run:
        description: 'Show what would be deleted without deleting (true/false)'
        required: false
        default: 'true'
      protect_patterns:
        description: 'Comma-separated globs to preserve (e.g. "release-*,sbom*")'
        required: false
        default: 'release-*,sbom*'
      include_patterns:
        description: 'Comma-separated globs to consider (default: all artifacts)'
        required: false
        default: '*'
      keep_latest_per_name:
        description: 'Always keep the N most-recent per artifact name'
        required: false
        default: '2'
      min_size_kb:
        description: 'Only delete artifacts >= this size (KB); 0 disables'
        required: false
        default: '0'
      sweep_runs:
        description: 'Also prune completed workflow runs older than 30 days (true/false)'
        required: false
        default: 'false'

permissions:
  actions: write   # required to list/delete artifacts and runs
  contents: read

concurrency:
  group: artifact-sweeper-${{ github.ref }}
  cancel-in-progress: true

jobs:
  sweep-artifacts:
    name: Sweep old artifacts
    runs-on: ubuntu-latest
    timeout-minutes: 25
    outputs:
      sweepruns: ${{ steps.cfg.outputs.sweepruns }}
    steps:
      - name: Resolve inputs
        id: cfg
        shell: bash
        run: |
          # For cron: inputs are empty; use defaults
          DAYS_TO_KEEP="${{ github.event_name == 'workflow_dispatch' && inputs.days_to_keep || '14' }}"
          GRACE_DAYS="${{ github.event_name == 'workflow_dispatch' && inputs.grace_days   || '2'  }}"
          DRY_RUN="${{ github.event_name == 'workflow_dispatch' && inputs.dry_run        || 'true' }}"
          PROTECT_PATTERNS="${{ github.event_name == 'workflow_dispatch' && inputs.protect_patterns || 'release-*,sbom*' }}"
          INCLUDE_PATTERNS="${{ github.event_name == 'workflow_dispatch' && inputs.include_patterns || '*' }}"
          KEEP_LATEST_PER_NAME="${{ github.event_name == 'workflow_dispatch' && inputs.keep_latest_per_name || '2' }}"
          MIN_SIZE_KB="${{ github.event_name == 'workflow_dispatch' && inputs.min_size_kb || '0' }}"
          SWEEP_RUNS="${{ github.event_name == 'workflow_dispatch' && inputs.sweep_runs   || 'false' }}"

          echo "days=${DAYS_TO_KEEP}" >> "$GITHUB_OUTPUT"
          echo "grace=${GRACE_DAYS}" >> "$GITHUB_OUTPUT"
          echo "dry=${DRY_RUN}" >> "$GITHUB_OUTPUT"
          echo "protect=${PROTECT_PATTERNS}" >> "$GITHUB_OUTPUT"
          echo "include=${INCLUDE_PATTERNS}" >> "$GITHUB_OUTPUT"
          echo "keepn=${KEEP_LATEST_PER_NAME}" >> "$GITHUB_OUTPUT"
          echo "minsiz=${MIN_SIZE_KB}" >> "$GITHUB_OUTPUT"
          echo "sweepruns=${SWEEP_RUNS}" >> "$GITHUB_OUTPUT"

      - name: Prune artifacts (age/filters/keep-N; retries/backoff)
        id: prune
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          days_to_keep: ${{ steps.cfg.outputs.days }}
          grace_days: ${{ steps.cfg.outputs.grace }}
          dry_run: ${{ steps.cfg.outputs.dry }}
          protect_patterns: ${{ steps.cfg.outputs.protect }}
          include_patterns: ${{ steps.cfg.outputs.include }}
          keep_latest_per_name: ${{ steps.cfg.outputs.keepn }}
          min_size_kb: ${{ steps.cfg.outputs.minsiz }}
          script: |
            const daysToKeep = Math.max(0, parseInt(core.getInput('days_to_keep') || '14', 10));
            const graceDays  = Math.max(0, parseInt(core.getInput('grace_days')  || '2',  10));
            const dryRun = (core.getInput('dry_run') || 'true').toLowerCase() === 'true';
            const keepLatestPerName = Math.max(0, parseInt(core.getInput('keep_latest_per_name') || '2', 10));
            const minSizeKB = Math.max(0, parseInt(core.getInput('min_size_kb') || '0', 10));

            const toList = (s) => (s ?? '').split(',').map(x => x.trim()).filter(Boolean);
            const protectList = toList(core.getInput('protect_patterns'));
            const includeList = toList(core.getInput('include_patterns') || '*');

            const globToRegex = (glob) => new RegExp('^' + glob
              .replace(/[.+^${}()|[\]\\]/g, '\\$&')
              .replace(/\*/g, '.*')
              .replace(/\?/g, '.') + '$', 'i');

            const protectRegexes = protectList.map(globToRegex);
            const includeRegexes = includeList.map(globToRegex);
            const matchesAny = (name, regs) => regs.length === 0 || regs.some(r => r.test(name));
            const cutoffMs = Date.now() - (daysToKeep + graceDays) * 24*60*60*1000;

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            async function delWithRetry(artifactId, attempt = 1) {
              try {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner, repo: context.repo.repo, artifact_id: artifactId
                });
                return true;
              } catch (e) {
                const status = e.status || 0;
                const msg = e.message || String(e);
                if (attempt < 5 && [403,429,502,503,504].includes(status)) {
                  const backoff = Math.min(2000 * attempt, 8000);
                  core.info(`Retry ${attempt} deleting ${artifactId} after ${backoff}ms (status ${status}: ${msg})`);
                  await sleep(backoff);
                  return delWithRetry(artifactId, attempt + 1);
                }
                core.error(`Permanent failure deleting ${artifactId}: ${status} ${msg}`);
                return false;
              }
            }

            core.info(`Days to keep: ${daysToKeep} (+ grace ${graceDays})`);
            core.info(`Dry run: ${dryRun}`);
            core.info(`Keep latest per name: ${keepLatestPerName}`);
            core.info(`Protect patterns: ${protectList.join(', ') || '(none)'}`);
            core.info(`Include patterns: ${includeList.join(', ') || '(all)'}`);
            core.info(`Min size to delete: ${minSizeKB} KB`);

            // List all artifacts (repo scope)
            const allArtifacts = await github.paginate(
              github.rest.actions.listArtifactsForRepo,
              { owner: context.repo.owner, repo: context.repo.repo, per_page: 100 }
            );

            // Group artifacts by name; keep newest first
            const byName = new Map();
            for (const a of allArtifacts) {
              const n = a.name || `artifact-${a.id}`;
              if (!byName.has(n)) byName.set(n, []);
              byName.get(n).push(a);
            }
            for (const [n, arr] of byName.entries()) {
              arr.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            }

            let total=0, considered=0, deleted=0, protectedCount=0, kept=0, errors=0, expired=0, tooSmall=0;
            let bytesDeleted=0, bytesScanned=0;

            for (const art of allArtifacts) {
              total++;
              const name = art.name || `artifact-${art.id}`;
              const createdAt = new Date(art.created_at || art.updated_at || Date.now()).getTime();
              const ageDays = Math.floor((Date.now() - createdAt) / (24*60*60*1000));
              const size = Number(art.size_in_bytes || 0);
              bytesScanned += size;

              // Exclude by include-patterns early
              if (!matchesAny(name, includeRegexes)) { kept++; continue; }

              // Protected names are always kept
              if (protectRegexes.length && protectRegexes.some(rx => rx.test(name))) { protectedCount++; continue; }

              // Keep newest N per name
              const siblings = byName.get(art.name || '') ?? [];
              const idx = siblings.findIndex(x => x.id === art.id);
              if (idx > -1 && idx < keepLatestPerName) { kept++; continue; }

              // Skip if newer than cutoff
              if (createdAt > cutoffMs) { kept++; continue; }

              // Size floor
              if (minSizeKB > 0 && size < minSizeKB * 1024) { tooSmall++; kept++; continue; }

              // From here on, it's "considered" for deletion
              considered++;

              // Auto-delete expired
              if (art.expired) {
                if (dryRun) {
                  core.warning(`EXPIRED (would delete): ${name} (#${art.id})`);
                } else {
                  const ok = await delWithRetry(art.id);
                  if (ok) { deleted++; bytesDeleted += size; } else { errors++; }
                }
                expired++;
                continue;
              }

              // Normal deletion path
              if (dryRun) {
                core.warning(`WOULD DELETE: ${name} (#${art.id}) [age=${ageDays}d, size=${size}B]`);
              } else {
                const ok = await delWithRetry(art.id);
                if (ok) { deleted++; bytesDeleted += size; } else { errors++; }
              }
            }

            const fmtBytes = (n) => {
              const u=['B','KB','MB','GB','TB']; let i=0,x=n;
              while(x>=1024&&i<u.length-1){x/=1024;i++;} return `${x.toFixed(2)} ${u[i]}`;
            };

            core.summary
              .addHeading('Artifact Sweeper Report')
              .addRaw(`**Dry run:** ${dryRun}\n\n`)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                ['Total scanned', String(total)],
                ['Considered (eligible)', String(considered)],
                ['Deleted', String(deleted)],
                ['Expired auto-deleted', String(expired)],
                ['Protected kept', String(protectedCount)],
                ['Recent/other kept', String(kept)],
                ['Too small kept', String(tooSmall)],
                ['Errors', String(errors)],
                ['Bytes scanned', fmtBytes(bytesScanned)],
                ['Bytes deleted (est.)', fmtBytes(bytesDeleted)],
              ])
              .addRaw('\n')
              .addList([
                `Days to keep: ${daysToKeep}`,
                `Grace days: ${graceDays}`,
                `Keep latest per name: ${keepLatestPerName}`,
                `Min size (KB): ${minSizeKB}`,
                `Protect patterns: ${protectList.join(', ') || '(none)'}`,
                `Include patterns: ${includeList.join(', ') || '(all)'}`
              ])
              .write();

            core.setOutput('total', String(total));
            core.setOutput('considered', String(considered));
            core.setOutput('deleted', String(deleted));
            core.setOutput('expired', String(expired));
            core.setOutput('protected', String(protectedCount));
            core.setOutput('kept', String(kept));
            core.setOutput('errors', String(errors));
            core.setOutput('bytes_deleted', String(bytesDeleted));

      - name: Save run summary to file
        if: always()
        shell: bash
        run: cp "$GITHUB_STEP_SUMMARY" artifact-sweeper-summary.md

      - name: Upload run summary
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: artifact-sweeper-summary
          path: artifact-sweeper-summary.md
          retention-days: 7

  sweep-runs:
    name: Sweep old workflow runs (optional)
    runs-on: ubuntu-latest
    needs: sweep-artifacts
    if: ${{ needs.sweep-artifacts.outputs.sweepruns == 'true' }}
    timeout-minutes: 15
    steps:
      - name: Delete completed runs older than 30 days (keep latest 20)
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const daysToKeep = 30;
            const keepLatest = 20;
            const cutoff = Date.now() - daysToKeep * 24 * 60 * 60 * 1000;

            let pruned = 0, total = 0, errors = 0;
            const runs = await github.paginate(
              github.rest.actions.listWorkflowRunsForRepo,
              { owner: context.repo.owner, repo: context.repo.repo, per_page: 100, status: 'completed' }
            );

            total = runs.length;
            const sorted = [...runs].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            const survivors = new Set(sorted.slice(0, keepLatest).map(r => r.id));

            for (const run of runs) {
              if (survivors.has(run.id)) continue;
              const createdAt = new Date(run.created_at).getTime();
              if (createdAt > cutoff) continue;
              try {
                await github.rest.actions.deleteWorkflowRun({
                  owner: context.repo.owner, repo: context.repo.repo, run_id: run.id
                });
                core.warning(`DELETED run ${run.id} (${run.name}) ${run.head_branch} @ ${run.created_at}`);
                pruned += 1;
              } catch (e) {
                core.error(`FAILED DELETE run ${run.id}: ${e.message || e}`);
                errors += 1;
              }
            }

            core.summary
              .addHeading('Workflow Run Sweeper')
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                ['Completed runs scanned', String(total)],
                ['Deleted', String(pruned)],
                ['Kept newest overall', String(keepLatest)],
                ['Age cutoff (days)', String(daysToKeep)],
                ['Errors', String(errors)],
              ])
              .write();
